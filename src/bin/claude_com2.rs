#![windows_subsystem = "windows"]

use iced::widget::{button, column, container, pick_list, row, scrollable, text, text_input};
use iced::{Element, Length, Subscription, Theme};
use serialport::{available_ports, SerialPort};
use std::collections::VecDeque;
use std::io::{self, Write};
use std::sync::{Arc, Mutex};
use std::time::Duration;

#[derive(Debug, Clone)]
pub enum Message {
    // –ù–∞–≤–∏–≥–∞—Ü–∏—è
    ShowTerminal,
    ShowSettings,
    ShowMonitor,
    ShowFileView,

    // Terminal
    InputChanged(String),
    SendData,
    ClearTerminal,

    // Settings
    PortSelected(String),
    BaudRateSelected(u32),
    ConnectPort,
    DisconnectPort,
    RefreshPorts,
    PortsUpdated(Vec<String>),

    // Monitor
    StartMonitoring,
    StopMonitoring,

    // File
    OpenFile,
    SaveLog,

    // Serial port
    DataReceived(String),
    PortError(String),

    // Internal messages
    Tick,
}

#[derive(Debug, Clone, Default)]
pub enum WindowState {
    #[default]
    Terminal,
    Settings,
    Monitor,
    FileView,
}

#[derive(Debug, Clone)]
pub struct PortSettings {
    pub port_name: Option<String>,
    pub baud_rate: u32,
    pub connected: bool,
}

impl Default for PortSettings {
    fn default() -> Self {
        Self {
            port_name: None,
            baud_rate: 9600,
            connected: false,
        }
    }
}

#[derive(Default)]
pub struct ComTerminal {
    current_window: WindowState,
    input_text: String,
    terminal_output: VecDeque<String>,
    port_settings: PortSettings,
    available_ports: Vec<String>,
    baud_rates: Vec<u32>,
    monitoring: bool,
    received_bytes: u64,
    sent_bytes: u64,
    log_file_path: Option<String>,
    serial_port: Option<Arc<Mutex<Box<dyn SerialPort>>>>,
}

impl ComTerminal {
    fn new() -> Self {
        let mut terminal = Self {
            current_window: WindowState::Terminal,
            input_text: String::new(),
            terminal_output: VecDeque::new(),
            port_settings: PortSettings::default(),
            available_ports: vec![],
            baud_rates: vec![9600, 19200, 38400, 57600, 115200],
            monitoring: false,
            received_bytes: 0,
            sent_bytes: 0,
            log_file_path: None,
            serial_port: None,
        };

        terminal
            .terminal_output
            .push_back("=== COM Terminal –∑–∞–ø—É—â–µ–Ω ===".to_string());
        terminal
            .terminal_output
            .push_back("–ó–∞–≥—Ä—É–∂–∞–µ–º —Å–ø–∏—Å–æ–∫ COM –ø–æ—Ä—Ç–æ–≤...".to_string());

        // Initial loading of ports
        match available_ports() {
            Ok(ports) => {
                terminal.available_ports = ports.into_iter().map(|p| p.port_name).collect();
                if terminal.available_ports.is_empty() {
                    terminal
                        .terminal_output
                        .push_back("‚ö†Ô∏è COM –ø–æ—Ä—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã".to_string());
                } else {
                    terminal.terminal_output.push_back(format!(
                        "üìã –ù–∞–π–¥–µ–Ω–æ –ø–æ—Ä—Ç–æ–≤: {}",
                        terminal.available_ports.len()
                    ));
                }
            }
            Err(e) => {
                terminal
                    .terminal_output
                    .push_back(format!("‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –ø–æ—Ä—Ç–æ–≤: {}", e));
            }
        }

        terminal
    }

    fn update(&mut self, message: Message) {
        match message {
            Message::ShowTerminal => {
                self.current_window = WindowState::Terminal;
            }
            Message::ShowSettings => {
                self.current_window = WindowState::Settings;
            }
            Message::ShowMonitor => {
                self.current_window = WindowState::Monitor;
            }
            Message::ShowFileView => {
                self.current_window = WindowState::FileView;
            }
            Message::InputChanged(text) => {
                self.input_text = text;
            }
            Message::SendData => {
                if !self.input_text.is_empty() && self.port_settings.connected {
                    let data = self.input_text.clone();
                    self.terminal_output.push_back(format!(">>> {}", data));
                    self.sent_bytes += data.len() as u64;

                    if let Some(port) = &self.serial_port {
                        let mut port_lock = port.lock().unwrap();
                        match port_lock.write_all(data.as_bytes()) {
                            Ok(_) => {
                                self.terminal_output
                                    .push_back(format!("‚úì –î–∞–Ω–Ω—ã–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã"));
                            }
                            Err(e) => {
                                self.terminal_output
                                    .push_back(format!("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö: {}", e));
                            }
                        }
                    }
                    self.input_text.clear();
                }
            }
            Message::ClearTerminal => {
                self.terminal_output.clear();
                self.terminal_output
                    .push_back("=== –¢–µ—Ä–º–∏–Ω–∞–ª –æ—á–∏—â–µ–Ω ===".to_string());
            }
            Message::PortSelected(port) => {
                self.port_settings.port_name = Some(port);
            }
            Message::BaudRateSelected(rate) => {
                self.port_settings.baud_rate = rate;
            }
            Message::ConnectPort => {
                if let Some(port_name) = &self.port_settings.port_name {
                    match serialport::new(port_name, self.port_settings.baud_rate)
                        .timeout(Duration::from_millis(100))
                        .open()
                    {
                        Ok(port) => {
                            self.port_settings.connected = true;
                            self.serial_port = Some(Arc::new(Mutex::new(port)));
                            self.terminal_output.push_back(format!(
                                "‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω –∫ {} –Ω–∞ {} baud",
                                port_name, self.port_settings.baud_rate
                            ));
                        }
                        Err(e) => {
                            self.terminal_output
                                .push_back(format!("‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ {}: {}", port_name, e));
                        }
                    }
                }
            }
            Message::DisconnectPort => {
                if let Some(port_name) = &self.port_settings.port_name {
                    self.port_settings.connected = false;
                    self.serial_port = None;
                    self.terminal_output
                        .push_back(format!("üîå –û—Ç–∫–ª—é—á–µ–Ω –æ—Ç {}", port_name));
                }
            }
            Message::RefreshPorts => match available_ports() {
                Ok(ports) => {
                    self.available_ports = ports.into_iter().map(|p| p.port_name).collect();
                    self.terminal_output
                        .push_back(format!("üìã –ù–∞–π–¥–µ–Ω–æ –ø–æ—Ä—Ç–æ–≤: {}", self.available_ports.len()));
                }
                Err(e) => {
                    self.terminal_output
                        .push_back(format!("‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –ø–æ—Ä—Ç–æ–≤: {}", e));
                }
            },
            Message::PortsUpdated(ports) => {
                self.available_ports = ports;
                if self.available_ports.is_empty() {
                    self.terminal_output
                        .push_back("‚ö†Ô∏è COM –ø–æ—Ä—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã".to_string());
                } else {
                    self.terminal_output
                        .push_back(format!("üìã –ù–∞–π–¥–µ–Ω–æ –ø–æ—Ä—Ç–æ–≤: {}", self.available_ports.len()));
                }
            }
            Message::StartMonitoring => {
                self.monitoring = true;
                self.terminal_output
                    .push_back("=== –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∑–∞–ø—É—â–µ–Ω ===".to_string());
            }
            Message::StopMonitoring => {
                self.monitoring = false;
                self.terminal_output
                    .push_back("=== –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω ===".to_string());
            }
            Message::OpenFile => {
                self.log_file_path = Some("example.log".to_string());
                self.terminal_output
                    .push_back("=== –§–∞–π–ª –æ—Ç–∫—Ä—ã—Ç (—Å–∏–º—É–ª—è—Ü–∏—è) ===".to_string());
            }
            Message::SaveLog => {
                self.terminal_output
                    .push_back("=== –õ–æ–≥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω (—Å–∏–º—É–ª—è—Ü–∏—è) ===".to_string());
            }
            Message::DataReceived(data) => {
                self.terminal_output.push_back(format!("<- {}", data));
                self.received_bytes += data.len() as u64;
            }
            Message::PortError(error) => {
                self.terminal_output.push_back(format!("‚ùå {}", error));
            }
            Message::Tick => {
                if let Some(port) = &self.serial_port {
                    let mut port_lock = port.lock().unwrap();
                    let mut buffer = [0; 1024];

                    match port_lock.read(&mut buffer) {
                        Ok(bytes_read) => {
                            if bytes_read > 0 {
                                let data =
                                    String::from_utf8_lossy(&buffer[..bytes_read]).to_string();
                                self.terminal_output.push_back(format!("<- {}", data));
                                self.received_bytes += data.len() as u64;
                            }
                        }
                        Err(ref e) if e.kind() == io::ErrorKind::TimedOut => {
                            // Do nothing on timeout
                        }
                        Err(e) => {
                            self.terminal_output
                                .push_back(format!("‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –∏–∑ –ø–æ—Ä—Ç–∞: {}", e));
                        }
                    }
                }
            }
        }
    }

    fn view(&self) -> Element<Message> {
        let nav_bar = row![
            self.nav_button("üñ•Ô∏è –¢–µ—Ä–º–∏–Ω–∞–ª", WindowState::Terminal),
            self.nav_button("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", WindowState::Settings),
            self.nav_button("üìä –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥", WindowState::Monitor),
            self.nav_button("üìÅ –§–∞–π–ª—ã", WindowState::FileView),
        ]
        .spacing(5)
        .padding([10, 20]);

        let content = match self.current_window {
            WindowState::Terminal => self.terminal_view(),
            WindowState::Settings => self.settings_view(),
            WindowState::Monitor => self.monitor_view(),
            WindowState::FileView => self.file_view(),
        };

        container(column![nav_bar, content].spacing(10))
            .width(Length::Fill)
            .height(Length::Fill)
            .into()
    }

    fn nav_button<'a>(&'a self, label: &'a str, window: WindowState) -> Element<'a, Message> {
        let is_active =
            std::mem::discriminant(&self.current_window) == std::mem::discriminant(&window);
        let message = match window {
            WindowState::Terminal => Message::ShowTerminal,
            WindowState::Settings => Message::ShowSettings,
            WindowState::Monitor => Message::ShowMonitor,
            WindowState::FileView => Message::ShowFileView,
        };
        button(text(label).size(if is_active { 16 } else { 14 }))
            .on_press(message)
            .into()
    }

    fn terminal_view(&self) -> Element<Message> {
        let status_text = if self.port_settings.connected {
            text(format!(
                "‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω –∫ {} ({})",
                self.port_settings
                    .port_name
                    .as_ref()
                    .unwrap_or(&"Unknown".to_string()),
                self.port_settings.baud_rate
            ))
            .size(14)
        } else {
            text("‚ùå –û—Ç–∫–ª—é—á–µ–Ω").size(14)
        };

        let terminal_display = container(scrollable(
            column(
                self.terminal_output
                    .iter()
                    .map(|line| text(line).size(12).into())
                    .collect::<Vec<_>>(),
            )
            .spacing(2)
            .padding(10),
        ))
        .height(Length::FillPortion(3))
        .width(Length::Fill);

        let input_row = row![
            text_input("–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É...", &self.input_text)
                .on_input(Message::InputChanged)
                .on_submit(Message::SendData)
                .width(Length::FillPortion(4)),
            button("–û—Ç–ø—Ä–∞–≤–∏—Ç—å")
                .on_press(Message::SendData)
                .width(Length::FillPortion(1)),
        ]
        .spacing(10)
        .padding(10);

        let controls = row![
            button("–û—á–∏—Å—Ç–∏—Ç—å").on_press(Message::ClearTerminal),
            text(format!(
                "–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {} –±–∞–π—Ç | –ü–æ–ª—É—á–µ–Ω–æ: {} –±–∞–π—Ç",
                self.sent_bytes, self.received_bytes
            ))
            .size(12),
        ]
        .spacing(10)
        .padding(10);

        column![status_text, terminal_display, input_row, controls,]
            .spacing(10)
            .padding(20)
            .into()
    }

    fn settings_view(&self) -> Element<Message> {
        let port_selection = column![
            text("COM –ü–æ—Ä—Ç:").size(16),
            pick_list(
                &self.available_ports[..],
                self.port_settings.port_name.as_ref(),
                Message::PortSelected,
            ),
            button("üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫").on_press(Message::RefreshPorts),
        ]
        .spacing(10);

        let baud_selection = column![
            text("–°–∫–æ—Ä–æ—Å—Ç—å (baud):").size(16),
            pick_list(
                &self.baud_rates[..],
                Some(self.port_settings.baud_rate),
                Message::BaudRateSelected,
            ),
        ]
        .spacing(10);

        let connection_controls = if self.port_settings.connected {
            button("üîå –û—Ç–∫–ª—é—á–∏—Ç—å—Å—è").on_press(Message::DisconnectPort)
        } else {
            button("üîå –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è").on_press(Message::ConnectPort)
        };

        let additional_settings = container(
            column![
                text("–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è:").size(16),
                text("‚Ä¢ –ë–∏—Ç—ã –¥–∞–Ω–Ω—ã—Ö: 8").size(14),
                text("‚Ä¢ –°—Ç–æ–ø-–±–∏—Ç—ã: 1").size(14),
                text("‚Ä¢ –ß–µ—Ç–Ω–æ—Å—Ç—å: None").size(14),
                text("‚Ä¢ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ—Ç–æ–∫–æ–º: None").size(14),
            ]
            .spacing(5),
        )
        .padding(15);

        column![
            text("–ù–∞—Å—Ç—Ä–æ–π–∫–∏ COM –ø–æ—Ä—Ç–∞").size(24),
            port_selection,
            baud_selection,
            connection_controls,
            additional_settings,
        ]
        .spacing(20)
        .padding(20)
        .into()
    }

    fn monitor_view(&self) -> Element<Message> {
        let stats = container(
            column![
                text(format!("üì§ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {} –±–∞–π—Ç", self.sent_bytes)).size(16),
                text(format!("üì• –ü–æ–ª—É—á–µ–Ω–æ: {} –±–∞–π—Ç", self.received_bytes)).size(16),
                text(format!(
                    "üìä –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥: {}",
                    if self.monitoring {
                        "üü¢ –ê–∫—Ç–∏–≤–µ–Ω"
                    } else {
                        "üî¥ –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"
                    }
                ))
                .size(16),
                if self.port_settings.connected {
                    text(format!(
                        "üîó –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ: {} ({})",
                        self.port_settings.port_name.as_ref().unwrap(),
                        self.port_settings.baud_rate
                    ))
                    .size(14)
                } else {
                    text("üîó –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ: –û—Ç–∫–ª—é—á–µ–Ω–æ").size(14)
                },
            ]
            .spacing(10),
        )
        .padding(20);

        let controls = if self.monitoring {
            button("‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥").on_press(Message::StopMonitoring)
        } else {
            button("‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥").on_press(Message::StartMonitoring)
        };

        let chart_placeholder = container(
            text("üìà –ó–¥–µ—Å—å –±—É–¥–µ—Ç –≥—Ä–∞—Ñ–∏–∫ —Ç—Ä–∞—Ñ–∏–∫–∞\n(TODO: –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å plotters)").size(14),
        )
        .padding(30)
        .height(Length::FillPortion(2))
        .width(Length::Fill);

        column![
            text("–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ COM –ø–æ—Ä—Ç–∞").size(24),
            stats,
            controls,
            chart_placeholder,
        ]
        .spacing(20)
        .padding(20)
        .into()
    }

    fn file_view(&self) -> Element<Message> {
        let file_info = container(if let Some(path) = &self.log_file_path {
            text(format!("üìÑ –¢–µ–∫—É—â–∏–π —Ñ–∞–π–ª: {}", path)).size(14)
        } else {
            text("üìÑ –§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω").size(14)
        })
        .padding(15);

        let file_controls = row![
            button("üìÅ –û—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª").on_press(Message::OpenFile),
            button("üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ª–æ–≥").on_press(Message::SaveLog),
        ]
        .spacing(10);

        let log_preview = container(scrollable(
            column(
                self.terminal_output
                    .iter()
                    .take(10)
                    .map(|line| text(line).size(12).into())
                    .collect::<Vec<_>>(),
            )
            .spacing(2)
            .padding(10),
        ))
        .height(Length::FillPortion(2))
        .width(Length::Fill);

        column![
            text("–†–∞–±–æ—Ç–∞ —Å —Ñ–∞–π–ª–∞–º–∏").size(24),
            file_info,
            file_controls,
            text("–ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–æ—Å–º–æ—Ç—Ä –ª–æ–≥–∞:").size(16),
            log_preview,
        ]
        .spacing(20)
        .padding(20)
        .into()
    }

    fn subscription(&self) -> Subscription<Message> {
        if self.port_settings.connected {
            return iced::time::every(Duration::from_millis(100)).map(|_| Message::Tick);
        }
        Subscription::none()
    }

    fn title(&self) -> String {
        let status = if self.port_settings.connected {
            format!(
                " - –ü–æ–¥–∫–ª—é—á–µ–Ω –∫ {}",
                self.port_settings
                    .port_name
                    .as_ref()
                    .unwrap_or(&"Unknown".to_string())
            )
        } else {
            " - –û—Ç–∫–ª—é—á–µ–Ω".to_string()
        };

        match self.current_window {
            WindowState::Terminal => format!("COM Terminal - –¢–µ—Ä–º–∏–Ω–∞–ª{}", status),
            WindowState::Settings => format!("COM Terminal - –ù–∞—Å—Ç—Ä–æ–π–∫–∏{}", status),
            WindowState::Monitor => format!("COM Terminal - –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥{}", status),
            WindowState::FileView => format!("COM Terminal - –§–∞–π–ª—ã{}", status),
        }
    }

    fn theme(&self) -> Theme {
        Theme::Dark
    }
}

pub fn main() -> iced::Result {
    iced::application("COM Terminal", ComTerminal::update, ComTerminal::view)
        .theme(ComTerminal::theme)
        .subscription(ComTerminal::subscription)
        .run_with(|| (ComTerminal::new(), iced::Task::none()))
}
