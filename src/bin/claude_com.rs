#![windows_subsystem = "windows"]
use iced::executor;
use iced::widget::{button, column, container, pick_list, row, scrollable, text, text_input};
use iced::{Application, Command, Element, Renderer, Settings, Subscription, Theme};
use serialport::{available_ports, SerialPort};
use std::collections::VecDeque;
use std::io::Write;
use std::io::{self, BufReader};
use std::sync::{Arc, Mutex};
use std::time::Duration;

#[derive(Debug, Clone)]
pub enum Message {
    // –ù–∞–≤–∏–≥–∞—Ü–∏—è
    ShowTerminal,
    ShowSettings,
    ShowMonitor,
    ShowFileView,

    // Terminal
    InputChanged(String),
    SendData,
    ClearTerminal,

    // Settings
    PortSelected(String),
    BaudRateSelected(u32),
    ConnectPort,
    DisconnectPort,
    RefreshPorts,
    PortsUpdated(Vec<String>),

    // Monitor
    StartMonitoring,
    StopMonitoring,

    // File
    OpenFile,
    SaveLog,
    // Serial port
    DataReceived(String),
    SendResult(String),
    PortError(String),
}

#[derive(Debug, Clone, Default)]
pub enum WindowState {
    #[default] // –£–∫–∞–∑—ã–≤–∞–µ–º, —á—Ç–æ Terminal - —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    Terminal,
    Settings,
    Monitor,
    FileView,
}

#[derive(Debug, Clone)]
pub struct PortSettings {
    pub port_name: Option<String>,
    pub baud_rate: u32,
    pub connected: bool,
}

impl Default for PortSettings {
    fn default() -> Self {
        Self {
            port_name: None,
            baud_rate: 9600,
            connected: false,
        }
    }
}
#[derive(Default)]
pub struct ComTerminal {
    current_window: WindowState,

    // Terminal data
    input_text: String,
    terminal_output: VecDeque<String>,

    // Settings
    port_settings: PortSettings,
    available_ports: Vec<String>,
    baud_rates: Vec<u32>,

    // Monitor
    monitoring: bool,
    received_bytes: u64,
    sent_bytes: u64,

    // File
    log_file_path: Option<String>,

    // Serial port
    serial_port: Option<Arc<Mutex<Box<dyn SerialPort>>>>,
}

impl ComTerminal {
    fn new() -> (Self, Task<Message>) {
        let mut terminal = Self {
            current_window: WindowState::Terminal,
            input_text: String::new(),
            terminal_output: VecDeque::new(),
            port_settings: PortSettings::default(),
            available_ports: vec![],
            baud_rates: vec![9600, 19200, 38400, 57600, 115200],
            monitoring: false,
            received_bytes: 0,
            sent_bytes: 0,
            log_file_path: None,
            serial_port: None,
        };

        // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        terminal
            .terminal_output
            .push_back("=== COM Terminal –∑–∞–ø—É—â–µ–Ω ===".to_string());
        terminal
            .terminal_output
            .push_back("–ó–∞–≥—Ä—É–∂–∞–µ–º —Å–ø–∏—Å–æ–∫ COM –ø–æ—Ä—Ç–æ–≤...".to_string());

        (
            terminal,
            Task::perform(get_available_ports(), Message::PortsUpdated),
        )
    }

    fn title(&self) -> String {
        let status = if self.port_settings.connected {
            format!(
                " - –ü–æ–¥–∫–ª—é—á–µ–Ω –∫ {}",
                self.port_settings
                    .port_name
                    .as_ref()
                    .unwrap_or(&"Unknown".to_string())
            )
        } else {
            " - –û—Ç–∫–ª—é—á–µ–Ω".to_string()
        };

        match self.current_window {
            WindowState::Terminal => format!("COM Terminal - –¢–µ—Ä–º–∏–Ω–∞–ª{}", status),
            WindowState::Settings => format!("COM Terminal - –ù–∞—Å—Ç—Ä–æ–π–∫–∏{}", status),
            WindowState::Monitor => format!("COM Terminal - –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥{}", status),
            WindowState::FileView => format!("COM Terminal - –§–∞–π–ª—ã{}", status),
        }
    }

    fn update(&mut self, message: Message) -> Task<Message> {
        match message {
            // –ù–∞–≤–∏–≥–∞—Ü–∏—è
            Message::ShowTerminal => {
                self.current_window = WindowState::Terminal;
                Task::none()
            }
            Message::ShowSettings => {
                self.current_window = WindowState::Settings;
                Task::none()
            }
            Message::ShowMonitor => {
                self.current_window = WindowState::Monitor;
                Task::none()
            }
            Message::ShowFileView => {
                self.current_window = WindowState::FileView;
                Task::none()
            }

            // Terminal
            Message::InputChanged(text) => {
                self.input_text = text;
                Task::none()
            }
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è Message::SendData –≤ update
            Message::SendData => {
                if !self.input_text.is_empty() && self.port_settings.connected {
                    let data = self.input_text.clone();
                    self.terminal_output.push_back(format!(">>> {}", data));
                    self.sent_bytes += data.len() as u64;

                    self.input_text.clear();

                    if let Some(port) = &self.serial_port {
                        let port_clone = port.clone();

                        // –ó–∞–ø—É—Å–∫–∞–µ–º –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—É—é –∑–∞–¥–∞—á—É –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö
                        return Task::perform(send_data_to_port(port_clone, data), |result| {
                            match result {
                                Ok(message) => Message::SendResult(message),
                                Err(e) => Message::PortError(e.to_string()),
                            }
                        });
                    }
                }

                // –ï—Å–ª–∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–∞, –ø—Ä–æ—Å—Ç–æ –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º
                Task::none()
            }
            Message::SendResult(message) => {
                self.terminal_output.push_back(message);
                Task::none()
            }

            Message::ClearTerminal => {
                self.terminal_output.clear();
                self.terminal_output
                    .push_back("=== –¢–µ—Ä–º–∏–Ω–∞–ª –æ—á–∏—â–µ–Ω ===".to_string());
                Task::none()
            }

            // Settings
            Message::PortSelected(port) => {
                self.port_settings.port_name = Some(port);
                Task::none()
            }
            Message::BaudRateSelected(rate) => {
                self.port_settings.baud_rate = rate;
                Task::none()
            }
            Message::ConnectPort => {
                if let Some(port_name) = &self.port_settings.port_name {
                    match serialport::new(port_name, self.port_settings.baud_rate)
                        .timeout(Duration::from_millis(1000))
                        .open()
                    {
                        Ok(port) => {
                            self.port_settings.connected = true;
                            self.serial_port = Some(Arc::new(Mutex::new(port)));
                            self.terminal_output.push_back(format!(
                                "‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω –∫ {} –Ω–∞ {} baud",
                                port_name, self.port_settings.baud_rate
                            ));
                            // –ó–∞–ø—É—Å–∫–∞–µ–º –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—É—é –∑–∞–¥–∞—á—É –¥–ª—è —á—Ç–µ–Ω–∏—è –ø–æ—Ä—Ç–∞
                            let port_clone = self.serial_port.clone().unwrap();
                            return Task::perform(
                                read_from_port(port_clone),
                                |result| match result {
                                    Ok(data) => Message::DataReceived(data),
                                    Err(e) => Message::PortError(e.to_string()),
                                },
                            );
                        }
                        Err(e) => {
                            self.terminal_output
                                .push_back(format!("‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ {}: {}", port_name, e));
                        }
                    }
                }
                Task::none()
            }
            Message::DisconnectPort => {
                if let Some(port_name) = &self.port_settings.port_name {
                    self.port_settings.connected = false;
                    self.serial_port = None;
                    self.terminal_output
                        .push_back(format!("üîå –û—Ç–∫–ª—é—á–µ–Ω –æ—Ç {}", port_name));
                }
                Task::none()
            }
            Message::RefreshPorts => Task::perform(get_available_ports(), Message::PortsUpdated),
            Message::PortsUpdated(ports) => {
                self.available_ports = ports;
                if self.available_ports.is_empty() {
                    self.terminal_output
                        .push_back("‚ö†Ô∏è COM –ø–æ—Ä—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã".to_string());
                } else {
                    self.terminal_output
                        .push_back(format!("üìã –ù–∞–π–¥–µ–Ω–æ –ø–æ—Ä—Ç–æ–≤: {}", self.available_ports.len()));
                }
                Task::none()
            }

            // Monitor
            Message::StartMonitoring => {
                self.monitoring = true;
                self.terminal_output
                    .push_back("=== –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∑–∞–ø—É—â–µ–Ω ===".to_string());
                Task::none()
            }
            Message::StopMonitoring => {
                self.monitoring = false;
                self.terminal_output
                    .push_back("=== –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω ===".to_string());
                Task::none()
            }

            // File
            Message::OpenFile => {
                // TODO: Implement file dialog with rfd
                self.log_file_path = Some("example.log".to_string());
                self.terminal_output
                    .push_back("=== –§–∞–π–ª –æ—Ç–∫—Ä—ã—Ç (—Å–∏–º—É–ª—è—Ü–∏—è) ===".to_string());
                Task::none()
            }
            Message::SaveLog => {
                // TODO: Save terminal output to file
                self.terminal_output
                    .push_back("=== –õ–æ–≥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω (—Å–∏–º—É–ª—è—Ü–∏—è) ===".to_string());
                Task::none()
            }
            Message::DataReceived(data) => {
                self.terminal_output.push_back(format!("<- {}", data));

                // –ó–∞–ø—É—Å–∫–∞–µ–º –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—É—é –∑–∞–¥–∞—á—É –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —á—Ç–µ–Ω–∏—è
                let port_clone = self.serial_port.clone().unwrap();
                return Task::perform(read_from_port(port_clone), |result| match result {
                    Ok(data) => Message::DataReceived(data),
                    Err(e) => Message::PortError(e.to_string()),
                });
            }
            Message::PortError(error) => {
                self.terminal_output.push_back(format!("‚ùå {}", error));
                Task::none()
            }
        }
    }

    fn view(&self) -> Element<Message> {
        let nav_bar = row![
            self.nav_button("üñ•Ô∏è –¢–µ—Ä–º–∏–Ω–∞–ª", WindowState::Terminal, Message::ShowTerminal),
            self.nav_button("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", WindowState::Settings, Message::ShowSettings),
            self.nav_button("üìä –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥", WindowState::Monitor, Message::ShowMonitor),
            self.nav_button("üìÅ –§–∞–π–ª—ã", WindowState::FileView, Message::ShowFileView),
        ]
        .spacing(5)
        .padding([10, 20]);

        let content = match self.current_window {
            WindowState::Terminal => self.terminal_view(),
            WindowState::Settings => self.settings_view(),
            WindowState::Monitor => self.monitor_view(),
            WindowState::FileView => self.file_view(),
        };

        container(column![nav_bar, content].spacing(10))
            .width(Length::Fill)
            .height(Length::Fill)
            .into()
    }

    fn nav_button<'a>(
        &'a self,
        label: &'a str,
        window: WindowState,
        message: Message,
    ) -> Element<'a, Message> {
        let is_active =
            std::mem::discriminant(&self.current_window) == std::mem::discriminant(&window);

        button(text(label).size(if is_active { 16 } else { 14 }))
            .on_press(message)
            .into()
    }

    fn terminal_view(&self) -> Element<Message> {
        let status_text = if self.port_settings.connected {
            text(format!(
                "‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω –∫ {} ({})",
                self.port_settings
                    .port_name
                    .as_ref()
                    .unwrap_or(&"Unknown".to_string()),
                self.port_settings.baud_rate
            ))
            .size(14)
        } else {
            text("‚ùå –û—Ç–∫–ª—é—á–µ–Ω").size(14)
        };

        let terminal_display = container(scrollable(
            column(
                self.terminal_output
                    .iter()
                    .map(|line| text(line).size(12).into())
                    .collect::<Vec<_>>(),
            )
            .spacing(2)
            .padding(10),
        ))
        .height(Length::FillPortion(3))
        .width(Length::Fill);

        let input_row = row![
            text_input("–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É...", &self.input_text)
                .on_input(Message::InputChanged)
                .on_submit(Message::SendData)
                .width(Length::FillPortion(4)),
            button("–û—Ç–ø—Ä–∞–≤–∏—Ç—å")
                .on_press(Message::SendData)
                .width(Length::FillPortion(1)),
        ]
        .spacing(10)
        .padding(10);

        let controls = row![
            button("–û—á–∏—Å—Ç–∏—Ç—å").on_press(Message::ClearTerminal),
            text(format!(
                "–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {} –±–∞–π—Ç | –ü–æ–ª—É—á–µ–Ω–æ: {} –±–∞–π—Ç",
                self.sent_bytes, self.received_bytes
            ))
            .size(12),
        ]
        .spacing(10)
        .padding(10);

        column![status_text, terminal_display, input_row, controls,]
            .spacing(10)
            .padding(20)
            .into()
    }

    fn settings_view(&self) -> Element<Message> {
        let port_selection = column![
            text("COM –ü–æ—Ä—Ç:").size(16),
            pick_list(
                &self.available_ports[..],
                self.port_settings.port_name.as_ref(),
                Message::PortSelected
            ),
            button("üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫").on_press(Message::RefreshPorts),
        ]
        .spacing(10);

        let baud_selection = column![
            text("–°–∫–æ—Ä–æ—Å—Ç—å (baud):").size(16),
            pick_list(
                &self.baud_rates[..],
                Some(self.port_settings.baud_rate),
                Message::BaudRateSelected
            ),
        ]
        .spacing(10);

        let connection_controls = if self.port_settings.connected {
            button("üîå –û—Ç–∫–ª—é—á–∏—Ç—å—Å—è").on_press(Message::DisconnectPort)
        } else {
            button("üîå –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è").on_press(Message::ConnectPort)
        };

        let additional_settings = container(
            column![
                text("–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è:").size(16),
                text("‚Ä¢ –ë–∏—Ç—ã –¥–∞–Ω–Ω—ã—Ö: 8").size(14),
                text("‚Ä¢ –°—Ç–æ–ø-–±–∏—Ç—ã: 1").size(14),
                text("‚Ä¢ –ß–µ—Ç–Ω–æ—Å—Ç—å: None").size(14),
                text("‚Ä¢ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ—Ç–æ–∫–æ–º: None").size(14),
            ]
            .spacing(5),
        )
        .padding(15);

        column![
            text("–ù–∞—Å—Ç—Ä–æ–π–∫–∏ COM –ø–æ—Ä—Ç–∞").size(24),
            port_selection,
            baud_selection,
            connection_controls,
            additional_settings,
        ]
        .spacing(20)
        .padding(20)
        .into()
    }

    fn monitor_view(&self) -> Element<Message> {
        let stats = container(
            column![
                text(format!("üì§ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {} –±–∞–π—Ç", self.sent_bytes)).size(16),
                text(format!("üì• –ü–æ–ª—É—á–µ–Ω–æ: {} –±–∞–π—Ç", self.received_bytes)).size(16),
                text(format!(
                    "üìä –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥: {}",
                    if self.monitoring {
                        "üü¢ –ê–∫—Ç–∏–≤–µ–Ω"
                    } else {
                        "üî¥ –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"
                    }
                ))
                .size(16),
                if self.port_settings.connected {
                    text(format!(
                        "üîó –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ: {} ({})",
                        self.port_settings.port_name.as_ref().unwrap(),
                        self.port_settings.baud_rate
                    ))
                    .size(14)
                } else {
                    text("üîó –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ: –û—Ç–∫–ª—é—á–µ–Ω–æ").size(14)
                },
            ]
            .spacing(10),
        )
        .padding(20);

        let controls = if self.monitoring {
            button("‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥").on_press(Message::StopMonitoring)
        } else {
            button("‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥").on_press(Message::StartMonitoring)
        };

        let chart_placeholder = container(
            text("üìà –ó–¥–µ—Å—å –±—É–¥–µ—Ç –≥—Ä–∞—Ñ–∏–∫ —Ç—Ä–∞—Ñ–∏–∫–∞\n(TODO: –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å plotters)").size(14),
        )
        .padding(30)
        .height(Length::FillPortion(2))
        .width(Length::Fill);

        column![
            text("–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ COM –ø–æ—Ä—Ç–∞").size(24),
            stats,
            controls,
            chart_placeholder,
        ]
        .spacing(20)
        .padding(20)
        .into()
    }

    fn file_view(&self) -> Element<Message> {
        let file_info = container(if let Some(path) = &self.log_file_path {
            text(format!("üìÑ –¢–µ–∫—É—â–∏–π —Ñ–∞–π–ª: {}", path)).size(14)
        } else {
            text("üìÑ –§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω").size(14)
        })
        .padding(15);

        let file_controls = row![
            button("üìÅ –û—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª").on_press(Message::OpenFile),
            button("üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ª–æ–≥").on_press(Message::SaveLog),
        ]
        .spacing(10);

        let log_preview = container(scrollable(
            column(
                self.terminal_output
                    .iter()
                    .take(10) // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Å—Ç—Ä–æ–∫
                    .map(|line| text(line).size(12).into())
                    .collect::<Vec<_>>(),
            )
            .spacing(2)
            .padding(10),
        ))
        .height(Length::FillPortion(2))
        .width(Length::Fill);

        column![
            text("–†–∞–±–æ—Ç–∞ —Å —Ñ–∞–π–ª–∞–º–∏").size(24),
            file_info,
            file_controls,
            text("–ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–æ—Å–º–æ—Ç—Ä –ª–æ–≥–∞:").size(16),
            log_preview,
        ]
        .spacing(20)
        .padding(20)
        .into()
    }
    // –í –≤–∞—à–µ–º impl ComTerminal
    fn subscription(&self) -> iced::Subscription<Message> {
        if self.port_settings.connected {
            // –ó–¥–µ—Å—å –≤—ã –¥–æ–ª–∂–Ω—ã —Å–æ–∑–¥–∞—Ç—å –∏ –≤–µ—Ä–Ω—É—Ç—å –ø–æ–¥–ø–∏—Å–∫—É –Ω–∞ —á—Ç–µ–Ω–∏–µ –ø–æ—Ä—Ç–∞
            // –ù–∞–ø—Ä–∏–º–µ—Ä: iced::Subscription::from_recipe(MyPortReader { ... })
            todo!("Implement port reader subscription")
        } else {
            // –ï—Å–ª–∏ –ø–æ—Ä—Ç –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç—É—é –ø–æ–¥–ø–∏—Å–∫—É
            iced::Subscription::none()
        }
    }
}

// –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –ø–æ—Ä—Ç–æ–≤
async fn get_available_ports() -> Vec<String> {
    match available_ports() {
        Ok(ports) => {
            let mut port_names = Vec::new();
            for port in ports {
                port_names.push(port.port_name);
            }
            port_names
        }
        Err(_) => {
            // –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø–æ—Ä—Ç—ã, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
            Vec::new()
        }
    }
}
// –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —á—Ç–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
async fn read_from_port(
    port: Arc<Mutex<Box<dyn serialport::SerialPort>>>,
) -> Result<String, serialport::Error> {
    let mut port = port.lock().unwrap();
    let mut buffer: Vec<u8> = vec![0; 1024];

    loop {
        match port.read(buffer.as_mut_slice()) {
            Ok(bytes_read) => {
                if bytes_read > 0 {
                    let data = String::from_utf8_lossy(&buffer[..bytes_read]);
                    return Ok(data.to_string()); // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ä–∞–∑—É
                }
            }
            Err(e) => {
                if e.kind() != std::io::ErrorKind::TimedOut {
                    return Err(serialport::Error::new(
                        serialport::ErrorKind::Io(e.kind()),
                        "–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –ø–æ—Ä—Ç–∞",
                    ));
                }
            }
        }
    }
}
// –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö
async fn send_data_to_port(
    port: Arc<Mutex<Box<dyn serialport::SerialPort>>>,
    data: String,
) -> Result<String, serialport::Error> {
    let mut port = port.lock().unwrap();
    match port.write_all(data.as_bytes()) {
        Ok(_) => Ok(format!("‚úì –î–∞–Ω–Ω—ã–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã: {}", data)),
        Err(e) => Err(serialport::Error::new(
            serialport::ErrorKind::Io(e.kind()),
            "–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö",
        )),
    }
}
pub fn main() -> iced::Result {
    iced::application(
        "COM Terminal",      // –ó–∞–≥–æ–ª–æ–≤–æ–∫ –≤–∞—à–µ–≥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
        ComTerminal::update, // –§—É–Ω–∫—Ü–∏—è update
        ComTerminal::view,   // –§—É–Ω–∫—Ü–∏—è view
    )
    .subscription(ComTerminal::subscription) // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–¥–ø–∏—Å–∫—É
    .run()
}
